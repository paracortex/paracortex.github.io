---
layout: post
title: 数结算
date: 2017-08-14 00:23:24.000000000 +09:00
---
#### 1
程序设计=数据结构+算法
数据结构就是关系
分为逻辑结构
物理结构 （存储形式，不关心）
4种  1 集合结构，相互无关。 2线性结构，一串 3树形，一对多，金字塔 4图形结构
存储形式两种 顺序 ，链式
#### 2
合在一起，才使得数据结构有意义。
算法要求存储量低，时间效率高。
#### 3
2n+2,认为是n，  数字x，认为是1.因为是抽象
渐进增长，算法关注最高次项的阶数。
#### 4
执行次数T(n) = O(f(n))
大O记法。是指的指令条数，而不是算式里有n * n。一般必须涉及循环。
线性阶，for。。。循环。O(n).平方阶。。等等
对数阶 O(log(2)n)  while  <  ,  i*2
#### 5
常用的复杂度，O(1)<O(logn)<O(n)<O(nlogn)<O(n2)<O(n3)<O(2n)<O(n!)<O(nn)
空间复杂度就是查表
#### 6
很明显，读起来那么拗口，它肯定是官方用语。
抽象数据类型是ADT 比如point（x,y,z）
#### 7
并集 U
#### 8
线性表
#### 9
顺序存储结构O(n)的插入删除操作，O(1)的存读。希望固定的表，以及末端增加的表。
#### 10
链式存储结构，头节点指针指向第一个元素，数据为空，为了操作统一。不是必要。查找需要遍历
#### 11
链式，常用操作，都是O(n) 它的好处，是如果插入删除频繁，那么优势会体现。
#### 12
顺序存储结构，就是List，数组。
srand随机。srand(time(NULL));  根据时间得到随机。
srand()用来设置rand()产生随机数时的随机数种子。参数seed必须是个整数，通常可以利用geypid()或time(0)的返回值来当做seed。如果每次seed都设相同值，rand()所产生的随机数值每次就会一样，因此srand这个函数一定要放在循环外面或者是循环调用的外面，否则的话得到的是相同的数字。
在调用此函数产生随机数前，必须先利用srand()设好随机数种子，如果未设随机数种子，rand()在调用时会自动设随机数种子为1。rand()产生的是假随机数字，每次执行时是相同的。若要不同,以不同的值来初始化它.初始化的函数就是srand()
#### 13
我又不是知青，插什么队。
固定的数据，比如注册信息，就用顺序存储结构。因为不怎么改变。而链表就要用频繁更换的。
#### 14
静态链表
人总是要故去之后，才会变得伟大。那我的作品，哎不说了。
静态链表，就是数组。
含有游标的静态链表，尾端游标记录第一个有数据（不为空）第0个下表的游标指向第一个没数据的。末尾数据游标为0.
数据空的是一个空的链表，等于是一个链表。
动态链表用malloc 和 free。 而静态链表的插入法则u不同。
#### 15
静态链表的难点在于，插入一个之后，很多游标都要改变。静态链表插入在第i位置，则要从末尾游标开始数。i-1的游标给i。
#### 16
静态链表的删除，i位置。记得同时维护有数据的链表和无数据的链表。
静态链表是给没有指针的编程语言设计的，同时，也是一种思想。
迅速找到未知长度的单链表的中间节点。
#### 17
循环链表
指向指针的指针**pNode
#### 18
约瑟夫问题，第三个人死亡。while问题。有头，有临时，有当前的标记。
#### 19
判断单链表中是否有环。
p一次走一步，q从1-p，如果p=q但步数不同，则有环。
另外，快慢指针法，两指针会相撞。
#### 20
魔术师发牌  while break
拉丁方阵 每一行都有n个数字不重复，每一列也一样。
#### 21
双向链表
#### 22
移位加密，凯撒密码，维吉尼亚加密。
#### 23
栈和队列   Last  LIFO
栈就是线性表。后进先出。弹夹。浏览器，后退，就是一个栈。只在表尾（Top）操作。
Push入栈，Pop删除。
#### 24
指针相减，有一个处以elem type的过程。等于两个指针必须同类型。
#### 25
include 《math.h》
hash key 井号 hash sign，或者“pound”；#的英文发音有一种就是Sharp，#由4个+号组成，明显是c++的升级版
getchar(); 吸收键盘缓冲区的回车。
pow(2,i) 是求2的i次方；1的ascii是49
#### 26
逆波兰表达式。运算符号在后面。利用栈的特性 1 2 - 4 5 + * 入栈顺序。 (1-2) * (4+5)
#### 27
isdigit(c) 48-57  对应0-9的ascii码，判断是不是在这个范围。
atof(char * );字符转成浮点
#### 28
中缀表达式 后缀表达式
#### 29
一堆if else判断。
#### 30
队列和栈联系在一起。queue，是FIFO。
栈是历史记录，队列是链表实现比较多一些，都可以。栈是顺序存储结构。
有头节点。然后front和rear指针都指向它。
入队列，尾节点指向，rear指针移向。
插进去，吐出来。插进去，抽出来。  
注意判断只有一个元素的队列的入队列出队列的处理。
链队列建立在内存的动态区，应该及时销毁。
front指针总是指向空的头节点。
#### 31
队列也有顺序存储结构。出队列的时间复杂度是O(n)。打饭，打完全部前移。
如果首指针后移，会前面空住，后面溢出。叫做假溢出。如果循环，解决假溢出，但是容量又固定了。可以用取模运算，来循环。%
可以看到数组和指针的关联特性。
#### 32
递归。迭代，容易出问题，少用。汉诺塔，传染病问题，思路更简洁。？
递归需要入栈。
Sierpinsky谢宾斯基三角形
加卫苗 HPV
斐波那契迭代：for 循环就出来了。
或者递归：
```bash
int Fib(int i)
{
if(i < 2)
  return i == 0 ? 0 : 1;
return Fib(i-1) + Fib(i-2);

}
```
#### 33
调用自己的函数，叫做递归函数。最怕陷入退不出循环。结束条件是Fib i < 2 ;
阶乘
```bash
int Factorial(int n){
  if( 0 == n )
    return 1 ;
  else return n * Factorial(n-1) ;
}
```
LIFO可以递归。而且不用考虑内存动态分配的栈问题。
递归的时候记得，每一层的局部变量是自己的，不会更改。
分治思想
折半查找法是常见的查找方法
迭代：while
递归：也无非是比较，if else 里面再调用自身
#### 34
汉诺塔
XYZ三个柱子3，移动盘子
先将63个到Y上，64-Z，再63-Z。
```bash
#include <stdio.h>
void move(int n, char x, char y, char z)
{
  if(1 == n)
  {
    printf("%c-->%c\n", x, z);
  }
  else
  {
    move(n-1, x, z, y);
    printf("%c-->%c", x, z);
    move(n-1,y, x, z);
  }

}
```
#### 35
八皇后问题
回溯的典型问题
8 8 64格，共8格，不能横竖斜
```bash
void Eightqueen(int row, int n, int (*chess)[8] ) // 指向棋盘每一行的指针
{
  int chess2[8][8], i, j; //为了打印，留存一份
  for( i=0; i < 8 ; i++ )
  {
    for( j=0; j < 8 ; j++ )
    {
      chess2[i][j] = chess[i][j];
    }
  }
  if( 8 == row )// row 是起始行，应该是0-7，到了8就不行了。
  {
    for( j=0; j < 8 ; j++ )
    {
      printf("%d ", *(*(chess2 + i)+j));
    }
    printf("\n");
  }
  printf("\n");
  else{
    for( j=0; j < n ; j++ )
      {
        if( notDanger( row, j, chess))
        {
          for( i=0; i < 8 ; i++ )
          {
            *(*(chess2+row)+i) = 0;
          }
          *(*(chess2+row)+j) = 1;// 不危险的时候，置1， 下面走下一行。
          EightQueen( row+1, n, chess2);
        }
      }
  }
}
```
有一个定数的chess，所以notDanger函数里面可以进行判断。
notDanger判断列方向，以及四个角方向
#### 36
刚开始计算机算导弹，处理数值，后来才有字符串，用ascii码
字符串比大小，从首开始比较ASCII。 f 102 F 70
BruteForce算法。比较是否子串，复杂度O(m*n)
#### 37
KMP算法 3个人，避免重复遍历
问题由模式串决定，不是目标串。
根据模式串的重复特性。
#### 38
KMP算法中的next数组。
模式串的前缀和后缀（后缀不含当前失配项）
第一号元素是0，2号是1；之后按之前的前缀后缀相同数+1.组成next数组
#### 39
根据模式串求next数组。
j = next[j]; 这个是关键所在。失配的时候，前缀回到它的next值处。
因为next数组有前缀传递特性。前缀总是固定的。
#### 40
重复的，直接next数组值相等。
#### 41
数 1必须唯一根节点  2不能交叉，一旦分离不能聚合 3子树叫做度
#### 42
树，的存储结构，比如文件管理，数据库的存放，都是用的树存储结构。相对于之前的链、顺序。
双亲表示法：每个节点有数据和双亲所在的指针。等等
#### 43
树的度=最大子数量
双亲孩子表示法，每个孩子是链表
#### 44
二叉树BinaryTree
左子树右子树完全不同
满二叉树；完全二叉树，是满二叉树的子集，只是最后一层少两个。
#### 45
一堆数学性质
#### 46
树有很多存储结构，灵活。二叉树就可以用一维数组
二叉链表更适用。节点，结构体。
#### 47
遍历：前，中，后，层。理解起来有一些困难。
#### 48
根节点所在位置决定前中后遍历。遍历方式要扎实才好了解。前序：
建立并访问。记得双重指针，用测试的更准确。
用递归的好处，不需要知道有多少层，只要能截取停止符就好。
学会递归。
#### 49
线索二叉树，KMP后另一难点。
为了进一步节约空间资源。
用中序遍历，正好每隔开一个，就有一个叶子节点。叶子的两个指针位可以利用起来，存放前驱
遍历的前中后，记住进入了哪一个单元，一定剖析到最小的单元里。只有完全二叉树，才能隔一个节点有空位。
lChild lTag data  r    r
  孩子    0        1   后继
#### 50
所谓线索，就是索引方便。
前序遍历创建，找到根节点，通过指针索引，内存中的保存和前序创建无关。
递归，先假设存在，再信任并完善逻辑。
全局变量记录前驱，同时完善前驱的后继，然后变成新的前驱
顺便建立初始化的头节点。lchild ltag data rtag rchild
                      root  c         thread  rightmost
然后pre就等于它。
很多时候关键就靠调试去做吧。
#### 51
树、森林及二叉树的相互转换
父母保留长子，连接兄弟。
跟节点有右孩子，则可转换为森林。
#### 52
赫夫曼树Huffman编码。和数据压缩有关。赫夫曼是无损压缩。
叶子节点带权二叉树
60 70 80 90分，人数量乘以路径树。
WPL最小。就是赫夫曼树，也就是最优二叉树。
#### 53
定长编码，变长编码，前缀码（没有任何码字是其他码字的前缀）赫夫曼码就是前缀码
因为赫夫曼路径不同，所以不可能相同的前码。
#### 54
编码，走树。解码，走树。
根据ascii为数组的序号，值为频率进行遍历输入字符得到频数表。
pragma once用来防止某个头文件被多次include，ifndef，define，endif用来防止某个宏被多次定义
记住endif的作用
然后创立一个头结构体（数量，首指针）然后插入各个节点，形成频率从小到大的队列。
根据队列，反向形成树，并且生成很多中间节点，权=子节点的和。
压缩率主要是由被压缩文件本身决定的
建立table树，节点有源，新码，和下一个。头节点有first和next，next使得table动态延长。
#### 55
图，线性表-1对1，树-1对多；图G(V,E)图，顶点Vertex，边Edge（无向）=无序偶(),< >有序
V={A,B,C,D};E={(),(),()}        有向Arc，前面是弧尾。   简单图：没有双线和自身圈线。
无向完全图：任意两点都有边
稀疏图，稠密图，nlogn (n n2之间条边弧)带权的图称为网
#### 56
顶点的度：边数。入度，出度，有向。度=入+出
路径中没有重复顶点，称为简单（路径，回路，环）任意两点都有路径，则连通图
极大连通子图 = 连通分量 极大不要求最大。可有分立的多个。
有向图，叫做强连通图。强连通分量
生成树是1连通图2顶点不变，但是边=n-1，属于极小连通分量
有向数，1个根节点入度0，其余入度1
#### 57
图的存储结构
因为任何顶点不存在次序关系
邻接矩阵：顶点用一维数组；边弧用二维数组。无向图是对角线对称的。
        vertex[n]     arc【n】【n】
出度对应行，入度对应列。出行，入殓。
邻接矩阵（网），没有弧的，用正无穷表示。
如果边数很少，那么矩阵比较浪费。
#### 58
邻接表（无向图）顶点还是一维数组。每个顶点的邻接点用单链表。
邻接表有向图，出度流。入度=逆邻接表。
邻接表（网），链表里加一项，存放权值。
#### 59
十字链表：结合邻接表和逆。Orthogonal List。时间复杂度类似邻接表，根据需要创建，可以使用。
邻接多重表：无向图用邻接表，删除一条边，会非常繁琐。
边集数组：两个一维数组。边的数组由结构体组成。
本我id：兽性。自我ego。超我。意识阶段。。
#### 60
图的遍历（深度优先、广度优先）DFS  类似前序遍历
深度优先遍历搜索，比如右手，走未标记过的顶点。没有选择的时候，回退。递归。
#### 61
马踏棋盘算法（骑士周游问题）寻找哈密尔顿路径（全部经过且只经过一次的路径）
回溯法
先写注释，说明要完成哪一个模块
#### 62
广度优先遍历 类似层序遍历
每一个元素找满了下家，它就可以出队列。传销流
#### 63
最小生成树，Prim普里姆算法，通讯并成本最低。权值是建设成本，回想邻接矩阵的正无穷。
用邻接矩阵。从顶点出发
1选一个点A，在邻接矩阵里记录它所有的边。找到最小权值的点B，存入adjvex
2检索A、B行，整合min，存入adjvex，并且（邻接矩阵自动的）将已整合点的权置0.
#### 64
克鲁斯卡尔算法kruskal
从边出发。列出所有边，以begin，end，并且权值排序。
从小权边开始，覆盖重复点的，形成环路的，舍弃。判断该点是否进入了树。循环判断数组 f = parent[f],直到==0；
n==m   6==6,所以是环路。利用数组的序号传递特性，判断是否相等。
#### 65
最短路径
Dijkstra算法-求出所有路径的最短。步步紧逼 O(n2)
贪心算法（又称贪婪算法）是指，在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，他所做出的是在某种意义上的局部最优解。
贪心算法不是对所有问题都能得到整体最优解，关键是贪心策略的选择，选择的贪心策略必须具备无后效性，即某个状态以前的过程不会影响以后的状态，只与当前状态有关
迭代出来。
final数组，标记0、1也就是有没有求出来目前的路径值或者是空。
遍历w， min+G[k]【w] < (* D)【w】，则更新。 D 抄自G。
P数组，存放前驱节点。
Floyd算法 O(n3)
#### 66
Floyd是求所有到所有点的最短路径。
P数组是二维数组。P的意思是，第一步往哪个方向走。
#### 67
拓扑排序
DAG Directed Acyclic Graph图 无环的有向图
AOV active on vertex网 类似SOP图
有向图，拓扑排序：必须前面的指向后面的。算法：找到没有入度只出的，删除并删掉相关边。重复。
用邻接表（有旁表的）方便操作，因为要删除顶点。n个顶点，e条边，O(n+e)
#### 堆和栈的区别
一个由C/C++编译的程序占用的内存分为以下几个部分
1、栈区（stack）— 由编译器自动分配释放 ，存放函数的参数值，局部变量的值等。其
操作方式类似于数据结构中的栈。
2、堆区（heap） — 一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回
收 。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表，呵呵。
3、全局区（静态区）（static）—，全局变量和静态变量的存储是放在一块的，初始化的
全局变量和静态变量在一块区域， 未初始化的全局变量和未初始化的静态变量在相邻的另
一块区域。 - 程序结束后由系统释放。
4、文字常量区 —常量字符串就是放在这里的。 程序结束后由系统释放
5、程序代码区—存放函数体的二进制代码。

二、例子程序
这是一个前辈写的，非常详细
```bash
//main.cpp
int a = 0; 全局初始化区
char *p1; 全局未初始化区
main()
{
int b; 栈
char s[] = "abc"; 栈
char *p2; 栈
char *p3 = "123456"; 123456\0在常量区，p3在栈上。
static int c =0； 全局（静态）初始化区
p1 = (char *)malloc(10);
p2 = (char *)malloc(20);
分配得来得10和20字节的区域就在堆区。
strcpy(p1, "123456"); 123456\0放在常量区，编译器可能会将它与p3所指向的"123456"
优化成一个地方。
}
```
#### 68
关键路径
法拉利部件生产 AOE网 Activity on Edge，  源点（始点），终点（汇点）
AOV没有权值。权值最大的路径是关键路径。拓扑序列是关键路径的奠基。
#### 69
etv事件最早发生事件 vertex
ltv   在不耽干事的前提下能拖就拖
ete  Edge
lte
同拓扑结构，也用邻接表
关键路径就是etv和ltv相等的时候。
根据拓扑，计算加权时间。生成关键路径。
#### 69-2
查找算法
静态：常见。动态：数据在查找的过程中需要同时增减。
顺序查找for 循环，if == 判断。while少判断一次。
#### 70
插值查找就是按比例【折半查找书号，书架。O(Log2 n)】
插值有时比折半好，有时比折半差，但是量级同。
斐波那契又叫黄金比例查找。0.618:1
#### 71
线性索引查找，
稠密索引，引申关键码当目录。数据量不能太大。因为目录是1对1的。
分块索引，进一步分目录。块内部不一定要求有序，甚至是块内无序。块间有序。
倒排索引，由于不是由记录来确定属性值，而是由属性值来确定记录的位置，因而称为倒排索引(inverted index)
倒排索引一般表示为一个关键词，然后是它的频度（出现的次数），位置（出现在哪一篇文章或网页中，及有关的日期，作者等信息），它相当于为互联网上几千亿页网页做了一个索引，好比一本书的目录、标签一般。读者想看哪一个主题相关的章节，直接根据目录即可找到相关的页面。不必再从书的第一页到最后一页，一页一页的查找。
倒排索引由两个部分组成：单词词典和倒排文件。
####Lucene倒排索引原理
<1>取得关键词，删除无意义的，整合时态大小写
<2>建立倒排索引
关键字是按字符顺序排列的（lucene没有使用B树结构），因此lucene可以用二分搜索算法快速定位关键词
<3>实现
lucene将上面三列分别作为词典文件（Term Dictionary）、频率文件(frequencies)、位置文件 (positions)保存。其中词典文件不仅保存有每个关键词，还保留了指向频率文件和位置文件的指针，通过指针可以找到该关键字的频率信息和位置信息
<4>压缩算法
关键词压缩为<前缀长度，后缀>，例如：当前词为“阿拉伯语”，上一个词为“阿拉伯”，那么“阿拉伯语”压缩为<3，语>。
数字的压缩，数字只保存与上一个值的差值（
<5>应用原因
假设要查询单词 “live”，lucene先对词典二元查找、找到该词，通过指向频率文件的指针读出所有文章号，然后返回结果。词典通常非常小，因而，整个过程的时间是毫秒级的。 　　
而用普通的顺序匹配算法，不建索引，而是对所有文章的内容进行字符串匹配，这个过程将会相当缓慢，当文章数目很大时，时间往往是无法忍受的。
#### 72
二叉排序树
插入删除，对无序表，可以直接替换当前末尾指针和要删除单元，然后计数-1
但是无序的表查找效率不高。因此引入二叉排序树。
Binary Sort Tree
左子树总小于根，右子树总大于根。可以递归。
#### 73
中序遍历二叉排序树，就可以得到从小到大。
二叉树作为非线性的，查找速度可以，插入删除也方便。
#### 74
但是删除节点比较困难
叶子直接删，只有左、右，接上去。左右都有，那么中序下来，直接前驱和直接后继去替换比较好。
直接前驱没有右子树，直接后继没有左子树。
直接前驱：左子树的最右子树，然后分情况讨论一下。
#### 75
平衡二叉树（前提是排序树）avl 树
空树，左右都是平衡二叉树，且深度最大差1。BF平衡因子。
#### 76
实现原理，当新增量导致不平衡时，不平衡处旋转。
#### 77
原理又走了一遍。
#### 78
代码实现
#### 79
多路查找树，特例： 2-3 树。multi way search tree
硅技术比磁技术贵2个量级。内存比磁盘。
查找速度，不光考虑算法，还要考虑存储介质的速度和读取频率。
多路查找树，有2节点和3节点。2节点必须两个孩子，规则如二叉排序树。
3节点有3个孩子，也就是都是高度平衡的。所有叶子都在一个层次。
#### 80
2-3树插入原理。为了解决树的高度不能太深，反复访问硬盘不好。二叉树一个节点只能2个元素，所以引入2-3树
因为要求叶子平衡，所以插入删除比较麻烦。可以用2、3互变的思路。满了找上面，可以递归解决。上面满了，那么增加一层，并且因为上面满了，其他分支也容易拆多一层，3变2.
#### 81
2-3树的删除原理。
1970年，R.Bayer和E.mccreight提出了一种适用于外查找的树，它是一种平衡的多叉树，称为B树（或B-树、B_树）。
B 树又叫平衡多路查找树
#### 82
2-3-4树，添加删除，就是来回倒腾。
B树的阶，就是4. 2-3树是3. 按节点最大的。
k-1个元素的节点，有k个孩子。k的数量 m阶   m/2向上取整 ～ m 之间，是k的取值范围。
每一个分治节点有n（比如3个，它就有4个孩子）个元素，K是关键字（元素k1,k2,k3）A是指针（A1-4四个孩子）。中序遍历能排序。
顺着指针查找，比较关键字。b树阶数变大，查找效率就高了很多。
#### 83
散列表（哈希表）查找
顺序表是逐一查找。
有序表是类似二分法。都需要很多的比较。
散列表：记录的存储位置=f(关键字)。  f就是散列函数或者哈希函数。在一块连续空间中，就叫表。
散列技术
#### 84
除留余数法，对关键字取模。散列函数根据实际情况进行选取。
#### 85
散列冲突，检测到冲突之后，
1开放地址法：余数前+1，等等。或者+随机数，前者叫线性探测法，后者随机探测法。
2再散列函数法，调用第二个散列函数。
3链地址法。
4公共溢出区法。处理所有的冲突，集中。
#### 86
散列表代码实现
#### 87
排序算法
多个关键字的排序可以整合成单个关键字的排序
内排序，内存中。外排序，需要辅助空间。
#### 88
冒泡排序
从下往上，两两相邻比较，递减次数的排序。再加一层遍历，就可以梳理清楚顺序。
#### 89
选择顺序：向后找最小。替换。
#### 90
直接插入排序找到它的位置。
#### 91
IX -> VI   ,1乘以6，抹掉下面，Six。
希尔排序。之前排序都是O(n2)，提高到O(nlogn)
直接插入排序，跨度是1.希尔是逐渐缩小跨度。
#### 92
堆排序，对选择排序进行改进。O(nlogn)
大顶堆，根大于等于孩子。类似，小顶堆（在完全二叉树下，有层序遍历的下标关系。）
#### 93
完全二叉树，i，2i 2i+1.层序。
#### 94
归并排序
分成几坨，逐一比较。
#### 95
迭代实现，就是每次分小组，2的n次方。
#### 96
快速排序 二十世纪十大算法之一
冒泡排序的升级版本
插入：直接，希尔
选择：简单，堆
交换：冒泡，快速 * k, 0,n-1,基准点，
小于基准点的放左边，分左边右边递归调用。和基准点交换位置
#### 97
快速排序的优化：基准点，三数取中
#### 98
有时要求稳定排序，同分前后顺序不变。
内排序，外排序。
![My helpful screenshot]({{aoa.cloud}}/pics/algorithm.jpg)
![My helpful screenshot]({{aoa.cloud}}/pics/algo2.jpg)

不同场合，进行适当的改进。
